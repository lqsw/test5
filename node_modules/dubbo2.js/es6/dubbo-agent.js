"use strict";
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const socket_worker_1 = __importDefault(require("./socket-worker"));
const util_1 = require("./util");
const log = debug_1.default('dubbo:server-agent');
/**
 * 机器agent和socket-worker的管理容器
 * Agent可以理解为一台dubbo service的负载
 */
class DubboAgent {
    constructor() {
        /**
         * static factor method
         * @param agentAddrList 负载地址列表
         */
        this.from = (agentAddrs) => {
            log('create server-agent :|> %O', agentAddrs);
            //获取负载host:port列表
            process.nextTick(() => {
                for (let agentAddr of agentAddrs) {
                    //如果负载中存在该负载，继续下一个
                    if (this._serverAgentMap.has(agentAddr)) {
                        //when current worker was retry, add retry chance
                        const worker = this._serverAgentMap.get(agentAddr);
                        if (worker.isRetry) {
                            log(`${agentAddr} was retry`);
                            //add retry chance
                            worker.resetRetry();
                        }
                        continue;
                    }
                    util_1.traceInfo(`ServerAgent create SocketWorker: ${agentAddr}`);
                    const socketWorker = socket_worker_1.default.from(agentAddr).subscribe({
                        onConnect: this._subscriber.onConnect,
                        onData: this._subscriber.onData,
                        onClose: ({ host, pid, port }) => {
                            //delete close worker
                            this._clearCloseWorker(host + ':' + port);
                            //notify scheduler
                            this._subscriber.onClose({ pid });
                        },
                    });
                    this._serverAgentMap.set(agentAddr, socketWorker);
                }
            });
            return this;
        };
        /**
         * remove close socket-worker from server agent
         */
        this._clearCloseWorker = (agentAddr) => {
            //如果全部关闭
            log(`socket-worker#${agentAddr} was closed. delete this socket worker`);
            this._serverAgentMap.delete(agentAddr);
            util_1.traceErr(new Error(`socket-worker#${agentAddr} was closed. delete this socket worker`));
            if (util_1.isDevEnv) {
                log('SocketAgent current agentHost->', this._serverAgentMap.keys());
            }
        };
        this._serverAgentMap = new Map();
        this._subscriber = {
            onConnect: util_1.noop,
            onData: util_1.noop,
            onClose: util_1.noop,
        };
    }
    /**
     * 获取可用负载对应的socketWorker
     * @param agentAddrList
     */
    getAvailableSocketWorker(agentAddrList = []) {
        const availableAgentList = this._getAvailableSocketAgents(agentAddrList);
        const len = availableAgentList.length;
        if (len === 0) {
            util_1.traceErr(new Error(`agentAddrList->${agentAddrList.join()} could not find any avaliable socekt worker`));
            return null;
        }
        else if (len === 1) {
            return availableAgentList[0];
        }
        else {
            //match random
            return availableAgentList[Math.floor(Math.random() * len)];
        }
    }
    subscribe(subscriber) {
        this._subscriber = subscriber;
        return this;
    }
    /**
     * 查询一组负载可用的agent
     * @param agentAddrList
     */
    _getAvailableSocketAgents(agentAddrList) {
        let errMessage = [];
        let availableList = [];
        let dieList = [];
        for (let agentAddr of agentAddrList) {
            //die set
            if (!this._serverAgentMap.has(agentAddr)) {
                dieList.push(agentAddr);
            }
            const socketWorker = this._serverAgentMap.get(agentAddr);
            if (socketWorker && socketWorker.isAvaliable) {
                availableList.push(socketWorker);
            }
            else {
                errMessage.push(`${agentAddrList.join()}:|>${agentAddr} current state ${socketWorker ? socketWorker.status : 'die'}`);
            }
        }
        if (dieList.length > 0) {
            log(`recovery dieSet ${dieList.join()}`);
            util_1.traceInfo(`recovery dieSet ${dieList.join()}`);
            this.from(new Set(dieList));
        }
        //trace error
        if (errMessage.length > 0) {
            util_1.traceErr(new Error(errMessage.join()));
        }
        return availableList;
    }
}
exports.default = DubboAgent;

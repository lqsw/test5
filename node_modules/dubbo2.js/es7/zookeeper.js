"use strict";
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const ip_1 = __importDefault(require("ip"));
const node_zookeeper_client_1 = __importDefault(require("node-zookeeper-client"));
const querystring_1 = __importDefault(require("querystring"));
const dubbo_url_1 = __importDefault(require("./dubbo-url"));
const err_1 = require("./err");
const go_1 = require("./go");
const util_1 = require("./util");
const log = debug_1.default('dubbo:zookeeper');
const ipAddress = ip_1.default.address();
class ZkRegistry {
    constructor(props) {
        //========================private method==========================
        this._init = async (err) => {
            //zookeeper occur error
            if (err) {
                log(err);
                util_1.traceErr(err);
                this._subscriber.onError(err);
                return;
            }
            //zookeeper connected（may be occur many times）
            const { zkRoot, application: { name }, interfaces, } = this._props;
            //获取所有provider
            for (let inf of interfaces) {
                //当前接口在zookeeper中的路径
                const dubboServicePath = `/${zkRoot}/${inf}/providers`;
                //当前接口路径下的dubbo url
                const dubboServiceUrls = await this._getDubboServiceUrls(dubboServicePath, inf);
                //init
                this._dubboServiceUrlMap.set(inf, []);
                for (let serviceUrl of dubboServiceUrls) {
                    const url = dubbo_url_1.default.from(serviceUrl);
                    this._dubboServiceUrlMap.get(inf).push(url);
                }
                //写入consumer信息
                this._createConsumer({
                    name: name,
                    dubboInterface: inf,
                }).then(() => log('create Consumer finish'));
            }
            if (util_1.isDevEnv) {
                log('agentAddrSet: %O', this._allAgentAddrSet);
                log('dubboServiceUrl:|> %O', this._dubboServiceUrlMap);
            }
            this._agentAddrSet = this._allAgentAddrSet;
            this._subscriber.onData(this._allAgentAddrSet);
        };
        //========================zookeeper helper=========================
        /**
         * connect zookeeper
         */
        this._connect = (callback) => {
            const { register } = this._props;
            //debug log
            log(`connecting zkserver ${register}`);
            //connect
            this._client = node_zookeeper_client_1.default.createClient(register, {
                retries: 10,
                sessionTimeout: 60 * 1000,
            });
            //超时检测
            //node-zookeeper-client,有个bug，当连不上zk时会无限重连
            //手动做一个超时检测
            const { retries, sessionTimeout } = this._client.options;
            const timeId = setTimeout(() => {
                log(`Could not connect zk ${register}， time out`);
                this._client.close();
                callback(new err_1.ZookeeperTimeoutError(`ZooKeeper was connected ${register} time out. `));
            }, retries * sessionTimeout);
            //connected
            this._client.once('connected', () => {
                log(`connected to zkserver ${register}`);
                clearTimeout(timeId);
                callback(null);
                util_1.msg.emit('sys:ready');
            });
            //in order to trace connect info
            this._client.on('connected', () => {
                util_1.traceInfo(`connected to zkserver ${register} current state is ${this._client.getState()}`);
                callback(null);
            });
            //the connection between client and server is dropped.
            this._client.on('disconnected', () => {
                log(`zk ${register} had disconnected`);
                clearTimeout(timeId);
                callback(new err_1.ZookeeperDisconnectedError(`ZooKeeper was disconnected. current state is ${this._client.getState()} `));
            });
            this._client.on('expired', () => {
                log(`zk ${register} had disconnected`);
                callback(new err_1.ZookeeperExpiredError(`Zookeeper was session Expired Error current state ${this._client.getState()}`));
            });
            //connect
            this._client.connect();
        };
        this._getChildren = (path, watch) => {
            if (!watch) {
                watch = () => { };
            }
            return new Promise((resolve, reject) => {
                this._client.getChildren(path, watch, (err, children, stat) => {
                    if (err) {
                        reject(err);
                        return;
                    }
                    resolve({
                        children,
                        stat,
                    });
                });
            });
        };
        this._create = (path, mode) => {
            return new Promise((resolve, rejec) => {
                this._client.create(path, mode, (err, path) => {
                    if (err) {
                        rejec(err);
                        return;
                    }
                    resolve(path);
                });
            });
        };
        this._exists = (path) => {
            return new Promise((resolve, reject) => {
                this._client.exists(path, (err, stat) => {
                    if (err) {
                        reject(err);
                        return;
                    }
                    resolve(stat);
                });
            });
        };
        log(`new:|> %O`, props);
        this._props = props;
        //默认dubbo
        this._props.zkRoot = this._props.zkRoot || 'dubbo';
        //保存dubbo接口和服务url之间的映射关系
        this._dubboServiceUrlMap = new Map();
        this._agentAddrSet = new Set();
        //初始化订阅者
        this._subscriber = {
            onData: util_1.noop,
            onError: util_1.noop,
        };
        //初始化zookeeper的client
        this._connect(this._init);
    }
    //===========================public method=============================
    static from(props) {
        return new ZkRegistry(props);
    }
    /**
     * 根据dubbo调用上下文interface, group, version等，获取负载列表
     * @param ctx dubbo调用上下文
     */
    getAgentAddrList(ctx) {
        const { dubboInterface, version, group } = ctx;
        return this._dubboServiceUrlMap
            .get(dubboInterface)
            .filter(serviceProp => {
            const isSameVersion = serviceProp.version === version;
            //如果Group为null，就默认匹配， 不检查group
            //如果Group不为null，确保group和接口的group一致
            const isSameGroup = !group || group === serviceProp.group;
            return isSameGroup && isSameVersion;
        })
            .map(({ host, port }) => `${host}:${port}`);
    }
    /**
     * 根据dubbo调用上下文获取服务提供者的信息
     * @param ctx
     */
    getDubboServiceProp(ctx) {
        let { dubboInterface, version, group, invokeHost, invokePort } = ctx;
        const dubboServicePropList = this._dubboServiceUrlMap.get(dubboInterface);
        for (let prop of dubboServicePropList) {
            const isSameHost = prop.host === invokeHost;
            const isSamePort = prop.port === invokePort;
            const isSameVersion = prop.version === version;
            //如果Group为null，就默认匹配， 不检查group
            //如果Group不为null，确保group和接口的group一致
            const isSameGroup = !group || group === prop.group;
            if (isSameHost && isSamePort && isSameVersion && isSameGroup) {
                log('getProviderProps:|> %s', prop);
                return prop;
            }
        }
    }
    /**
     * 订阅者
     * @param subscriber
     */
    subscribe(subscriber) {
        this._subscriber = subscriber;
        return this;
    }
    /**
     * get current all agent address
     */
    get allAgentAddrSet() {
        return this._agentAddrSet;
    }
    /**
     * 获取所有的负载列表，通过agentAddrMap聚合出来
     * 这样有点Reactive的感觉，不需要考虑当中增加删除的动作
     */
    get _allAgentAddrSet() {
        const agentSet = new Set();
        for (let urlList of this._dubboServiceUrlMap.values()) {
            for (let url of urlList) {
                agentSet.add(url.host + ':' + url.port);
            }
        }
        return agentSet;
    }
    /**
     * 获取所有的provider列表
     * @param {string} dubboServicePath
     * @param dubboInterface
     * @returns {Promise<Array<string>>}
     * @private
     */
    async _getDubboServiceUrls(dubboServicePath, dubboInterface) {
        const { res, err } = await go_1.go(this._getChildren(dubboServicePath, this._watch(dubboServicePath, dubboInterface)));
        if (err) {
            log(`getChildren ${dubboServicePath} error ${err}`);
            util_1.traceErr(err);
            return [];
        }
        if (!res.children || res.children.length === 0) {
            util_1.traceErr(new Error(`zk get DubboSericeUrls result is empty with service path ${dubboServicePath} and interface ${dubboInterface}.`));
        }
        return (res.children || [])
            .map(child => decodeURIComponent(child))
            .filter(child => child.startsWith('dubbo://'));
    }
    _watch(dubboServicePath, dubboInterface) {
        //@ts-ignore
        return async (e) => {
            log(`trigger watch ${e}`);
            //会有概率性的查询节点为空，可以延时一些时间
            await util_1.delay(2000);
            const dubboServiceUrls = await this._getDubboServiceUrls(dubboServicePath, dubboInterface);
            //clear current dubbo interface
            const agentAddrList = [];
            const urls = [];
            for (let serviceUrl of dubboServiceUrls) {
                const url = dubbo_url_1.default.from(serviceUrl);
                const { host, port } = url;
                agentAddrList.push(`${host}:${port}`);
                urls.push(url);
            }
            this._createConsumer({
                name: this._props.application.name,
                dubboInterface: dubboInterface,
            }).then(() => log('create consumer finish'));
            this._dubboServiceUrlMap.set(dubboInterface, urls);
            if (agentAddrList.length === 0) {
                util_1.traceErr(new Error(`trigger watch ${e} agentList is empty`));
            }
            else {
                util_1.traceInfo(`trigger watch ${e} agentList ${agentAddrList.join(',')}`);
            }
            if (util_1.isDevEnv) {
                log('agentSet:|> %O', this._allAgentAddrSet);
                log('update dubboInterface %s providerList %O', dubboInterface, this._dubboServiceUrlMap.get(dubboInterface));
            }
            if (!util_1.eqSet(this._agentAddrSet, this._allAgentAddrSet)) {
                this._agentAddrSet = this._allAgentAddrSet;
                this._subscriber.onData(this._allAgentAddrSet);
            }
            else {
                log('no agent change');
            }
        };
    }
    /**
     * com.alibaba.dubbo.registry.zookeeper.ZookeeperRegistry
     */
    async _createConsumer(params) {
        let { name, dubboInterface } = params;
        const dubboSetting = this._props.dubboSetting.getDubboSetting(dubboInterface);
        if (!dubboSetting) {
            throw new Error(`Could not find group, version for ${dubboInterface} please check your dubbo setting`);
        }
        const queryParams = {
            interface: dubboInterface,
            application: name,
            category: 'consumers',
            method: '',
            revision: '',
            version: dubboSetting.version,
            group: dubboSetting.group,
            side: 'consumer',
            check: 'false',
        };
        //create root comsumer
        const consumerRoot = `/${this._props.zkRoot}/${dubboInterface}/consumers`;
        const err = await this._createRootConsumer(consumerRoot);
        if (err) {
            log('create root consumer: error %o', err);
            return;
        }
        //create comsumer
        const consumerUrl = consumerRoot +
            '/' +
            encodeURIComponent(`consumer://${ipAddress}/${dubboInterface}?${querystring_1.default.stringify(queryParams)}`);
        const exist = await go_1.go(this._exists(consumerUrl));
        if (exist.err) {
            log(`check consumer url: ${consumerUrl} failed`);
            return;
        }
        if (exist.res) {
            log(`check consumer url: ${consumerUrl} was existed.`);
            return;
        }
        const create = await go_1.go(this._create(consumerUrl, node_zookeeper_client_1.default.CreateMode.EPHEMERAL));
        if (create.err) {
            log(`check consumer url: ${decodeURIComponent(consumerUrl)}创建consumer失败 %o`, create.err);
            return;
        }
        log(`create successfully consumer url: ${decodeURIComponent(consumerUrl)}`);
    }
    async _createRootConsumer(consumer) {
        let { res, err } = await go_1.go(this._exists(consumer));
        //check error
        if (err) {
            return err;
        }
        // current consumer root path was existed.
        if (res) {
            return null;
        }
        //create current consumer path
        ({ err } = await go_1.go(this._create(consumer, node_zookeeper_client_1.default.CreateMode.PERSISTENT)));
        if (err) {
            return err;
        }
        log('create root comsumer %s successfull', consumer);
    }
}
exports.ZkRegistry = ZkRegistry;

"use strict";
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const dubbo_agent_1 = __importDefault(require("./dubbo-agent"));
const err_1 = require("./err");
const util_1 = require("./util");
const zookeeper_1 = require("./zookeeper");
const log = debug_1.default('dubbo:scheduler');
/**
 * scheduler
 * 1. 初始化zookeeper和socket-agent
 * 2. 接受所有的socket-worker的事件
 * 3. 处理用户的请求
 * 4. 接受zookeeper的变化，更新Server-agent
 */
class Scheduler {
    constructor(props, queue) {
        /**
         * handle request in queue
         * @param requestId
         */
        this._handleQueueRequest = requestId => {
            //record current status
            log(`handle requestId ${requestId}, current status: ${this._status}`);
            switch (this._status) {
                case "ready" /* READY */:
                    //发起dubbo的调用
                    this._handleDubboInvoke(requestId);
                    break;
                case "padding" /* PADDING */:
                    log('current scheduler was padding');
                    break;
                case "no_agent" /* NO_AGENT */:
                    this._handleFailed(requestId, new err_1.ScheduleError('Zookeeper Can not be find any agents'));
                    break;
                case "failded" /* FAILED */:
                    this._handleFailed(requestId, new err_1.ScheduleError('ZooKeeper Could not be connected'));
                    break;
            }
        };
        /**
         * 处理zookeeper的数据
         */
        this._handleZkClientOnData = (agentSet) => {
            //获取负载列表
            log(`get agent address:=> %O`, agentSet);
            //如果负载为空，也就是没有任何provider提供服务
            if (agentSet.size === 0) {
                this._status = "no_agent" /* NO_AGENT */;
                //将队列中的所有dubbo调用全调用失败
                const err = new err_1.ScheduleError('Can not be find any agents');
                this._queue.allFailed(err);
                util_1.traceErr(err);
                return;
            }
            //初始化dubboAgent
            this._dubboAgent.from(agentSet).subscribe({
                onConnect: this._handleOnConnect,
                onData: this._handleOnData,
                onClose: this._handleOnClose,
            });
        };
        /**
         * 处理zookeeper的错误
         */
        this._handleZkClientError = (err) => {
            log(err);
            //说明zookeeper连接不上
            if (err instanceof err_1.ZookeeperTimeoutError) {
                this._status = "failded" /* FAILED */;
            }
        };
        /**
         * 处理schedule的failed状态
         */
        this._handleFailed = (requestId, err) => {
            log('#requestId: %d scheduler was failed, err: %s', requestId, err);
            this._queue.failed(requestId, err);
        };
        this._handleOnConnect = ({ pid, host, port }) => {
            log(`scheduler receive SocketWorker connect pid#${pid} ${host}:${port}`);
            const agentHost = `${host}:${port}`;
            this._status = "ready" /* READY */;
            util_1.traceInfo(`scheduler receive SocketWorker connect pid#${pid} ${host}:${port}`);
            for (let ctx of this._queue.requestQueue.values()) {
                if (ctx.isNotScheduled) {
                    const agentHostList = this._zkClient.getAgentAddrList(ctx);
                    log('agentHostList-> %O', agentHostList);
                    //当前的socket是否可以处理当前的请求
                    if (agentHostList.indexOf(agentHost) != -1) {
                        this._handleDubboInvoke(ctx.requestId);
                    }
                }
            }
        };
        /**
         * 当收到数据的时候
         */
        this._handleOnData = ({ requestId, res, err, attachments, }) => {
            if (err) {
                this._queue.failed(requestId, err, attachments);
            }
            else {
                this._queue.resolve(requestId, res, attachments);
            }
        };
        /**
         * 处理某一个SocketWorker被关闭的状态
         */
        this._handleOnClose = ({ pid }) => {
            log(`SocketWorker#${pid} was close`);
            //查询之前哪些接口的方法被pid调用, 然后直接failfast
            const { requestQueue } = this._queue;
            for (let [requestId, ctx] of requestQueue) {
                if (ctx.pid === pid) {
                    this._handleFailed(requestId, new err_1.SocketError(`SocketWorker#${pid} had closed.`));
                }
            }
        };
        log(`new:|> %O`, props);
        this._status = "padding" /* PADDING */;
        this._queue = queue;
        this._queue.subscribe(this._handleQueueRequest);
        this._dubboAgent = new dubbo_agent_1.default();
        //init ZkClient and subscribe
        this._zkClient = zookeeper_1.ZkRegistry.from(props).subscribe({
            onData: this._handleZkClientOnData,
            onError: this._handleZkClientError,
        });
    }
    /**
     * static factory method
     * @param props
     */
    static from(props, queue) {
        return new Scheduler(props, queue);
    }
    /**
     * 发起dubbo调用
     * @param ctx
     * @param agentHostList
     */
    _handleDubboInvoke(requestId) {
        //get request context
        const ctx = this._queue.requestQueue.get(requestId);
        //get socket agent list
        const agentAddrList = this._zkClient.getAgentAddrList(ctx);
        log('agentAddrSet-> %O', agentAddrList);
        const worker = this._dubboAgent.getAvailableSocketWorker(agentAddrList);
        //if could not find any available socket agent worker
        if (!worker) {
            const { requestId, dubboInterface, version, group } = ctx;
            const msg = `requestId#${requestId}:Could not find any agent worker with ${dubboInterface}#${version}#${group} agentList: ${agentAddrList.join(',')}`;
            const err = new err_1.ScheduleError(msg);
            this._handleFailed(requestId, err);
            log(err);
            util_1.traceErr(err);
            return;
        }
        ctx.invokeHost = worker.host;
        ctx.invokePort = worker.port;
        const providerProps = this._zkClient.getDubboServiceProp(ctx);
        this._queue.consume(ctx.requestId, worker, providerProps);
    }
}
exports.default = Scheduler;

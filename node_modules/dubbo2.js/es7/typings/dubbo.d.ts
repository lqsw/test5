import { IDubboProps, IDubboProvider, IDubboSubscriber, IObservable, TDubboService } from './types';
/**
 * Dubbo
 *
 * 1. 连接注册中心zookeeper
 * 2. 发起远程dubbo service的方法调用
 * 3. 序列化/反序列化dubbo协议
 * 4. 管理tcp连接以及心跳
 * 5. 通过代理机制自动代理interface对应的方法
 * 6. 提供直连的方式快速测试接口
 * 7. Middleware
 * 8. 通过zone-context可以实现dubbo调用的全链路跟踪
 * 9. 集中消息管理
 */
export default class Dubbo<TService = Object> implements IObservable<IDubboSubscriber> {
    constructor(props: IDubboProps);
    private _interfaces;
    private _readyResolve;
    private _subscriber;
    private readonly _queue;
    private readonly _props;
    private readonly _middleware;
    private readonly _service;
    /**
     * static factory method
     * @param props
     */
    static from(props: IDubboProps): Dubbo<Object>;
    /**
     * get service from dubbo container
     */
    readonly service: TDubboService<TService>;
    /**
     * 代理dubbo的服务
     */
    proxyService: <T>(provider: IDubboProvider) => T;
    /**
     * extends middleware, api: the same as koa
     * @param fn
     */
    use(fn: any): this;
    /**
     * dubbo的连接是异步的，有没有连接成功，通常需要到runtime才可以知道
     * 这时候可能会给我们一些麻烦，我们必须发出一个请求才能知道dubbo状态
     * 基于这种场景，我们提供一个方法，来告诉外部，dubbo是不是初始化成功，
     * 这样在node启动的过程中就知道dubbo的连接状态，如果连不上我们就可以
     * 及时的fixed
     *
     * 比如和egg配合起来，egg提供了beforeStart方法
     * 通过ready方法来等待dubbo初始化成功
     *
     * //app.js
     * export default (app: EggApplication) => {
     *   const dubbo = Dubbo.from({....})
     *   app.beforeStart(async () => {
     *     await dubbo.ready();
     *     console.log('dubbo was ready...');
     *   })
     * }
     *
     * 其他的框架类似
     */
    ready(): Promise<{}>;
    subscribe(subscriber: IDubboSubscriber): void;
    private _initMsgListener;
    /**
     * 注册服务到dubbo容器中
     * @param service dubbo需要管理的接口服务
     * service style:
     * {[key: string]: (dubbo): T => dubbo.proxyService<T>({...})}
     */
    private _registryService;
}

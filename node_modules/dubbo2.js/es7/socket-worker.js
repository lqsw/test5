"use strict";
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const net_1 = __importDefault(require("net"));
const decode_1 = require("./decode");
const decode_buffer_1 = __importDefault(require("./decode-buffer"));
const encode_1 = __importDefault(require("./encode"));
const heartbeat_1 = __importDefault(require("./heartbeat"));
const statistics_1 = __importDefault(require("./statistics"));
const util_1 = require("./util");
let pid = 0;
//重试次数
const RETRY_NUM = 20;
//重试频率
const RETRY_TIME = 3000;
//心跳频率
const HEART_BEAT = 180 * 1000;
const log = debug_1.default('dubbo:socket-worker');
/**
 * 具体处理tcp底层通信的模块
 * 1 负责socket的创建和通信
 * 2.负责dubbo的序列化和反序列化
 * 3.socket断开自动重试
 */
class SocketWorker {
    constructor(host, port) {
        this._onConnected = () => {
            log(`SocketWorker#${this.pid} <=connected=> ${this.host}:${this.port}`);
            util_1.traceInfo(`SocketWorker#${this.pid} <=connected=> ${this.host}:${this.port}`);
            //set current status
            this._status = "CONNECTED" /* CONNECTED */;
            //reset retry number
            this._retry = RETRY_NUM;
            //notifiy subscriber, the socketworker was connected successfully
            this._subscriber.onConnect({
                pid: this.pid,
                host: this.host,
                port: this.port,
            });
            //heartbeart
            this._heartBeatTimer = setInterval(() => {
                log('emit heartbeat');
                this._socket.write(heartbeat_1.default.encode());
            }, HEART_BEAT);
        };
        this._onData = data => {
            log(`SocketWorker#${this.pid}  =receive data=> ${this.host}:${this.port}`);
            this._decodeBuff.receive(data);
        };
        this._onError = (error) => {
            log(`SocketWorker#${this.pid} <=occur error=> ${this.host}:${this.port} ${error}`);
            util_1.traceErr(new Error(`SocketWorker#${this.pid} <=occur error=> ${this.host}:${this.port} ${error.message}`));
            clearInterval(this._heartBeatTimer);
        };
        this._onClose = (hadError) => {
            log(`SocketWorker#${this.pid} <=closed=> ${this.host}:${this.port} hasError: ${hadError} retry: ${this._retry}`);
            util_1.traceErr(new Error(`SocketWorker#${this.pid} <=closed=> ${this.host}:${this.port} hadError: ${hadError} retry: ${this._retry}`));
            //clear buffer
            this._decodeBuff.clearBuffer();
            clearInterval(this._heartBeatTimer);
            if (this._retry > 0) {
                //set current status
                this._status = "RETRY" /* RETRY */;
                //retry when delay RETRY_TIME
                setTimeout(() => {
                    this._retry--;
                    this._initSocket();
                }, RETRY_TIME);
            }
            else {
                this._status = "CLOSED" /* CLOSED */;
                this._socket.destroy();
                //set state closed and notified socket-pool
                this._subscriber.onClose({
                    pid: this.pid,
                    host: this.host,
                    port: this.port,
                });
            }
        };
        this._onSubscribeDecodeBuff = (data) => {
            const json = decode_1.decode(data);
            log(`SocketWorker#${this.pid} <=received=> dubbo result %O`, json);
            this._subscriber.onData(json);
        };
        this.pid = ++pid;
        //statistics info
        statistics_1.default['pid#' + this.pid] = 0;
        this.host = host;
        this.port = port;
        this._retry = RETRY_NUM;
        this._status = "PADDING" /* PADDING */;
        log('new SocketWorker#%d|> %s %s', pid, host + ':' + port, this._status);
        util_1.traceInfo(`new SocketWorker#${this.pid} |> ${host + ':' + port}`);
        //init subscriber
        this._subscriber = {
            onConnect: util_1.noop,
            onData: util_1.noop,
            onClose: util_1.noop,
        };
        //init decodeBuffer
        this._decodeBuff = decode_buffer_1.default.from(pid).subscribe(this._onSubscribeDecodeBuff);
        //init socket
        this._initSocket();
    }
    //==================================public method==========================
    /**
     * static factory method
     * @param url(host:port)
     */
    static from(url) {
        const [host, port] = url.split(':');
        return new SocketWorker(host, Number(port));
    }
    /**
     * send data to dubbo service
     * @param ctx dubbo context
     */
    write(ctx) {
        log(`SocketWorker#${this.pid} =invoked=> ${ctx.requestId}`);
        statistics_1.default['pid#' + this.pid] = ++statistics_1.default['pid#' + this.pid];
        //current dubbo context record the pid
        //when current worker close, fail dubbo request
        ctx.pid = this.pid;
        const encoder = new encode_1.default(ctx);
        this._socket.write(encoder.encode());
    }
    get status() {
        return this._status;
    }
    /**
     * current status is whether avaliable or not
     */
    get isAvaliable() {
        return this._status === "CONNECTED" /* CONNECTED */;
    }
    /**
     * current status whether retry or not
     */
    get isRetry() {
        return this._status === "RETRY" /* RETRY */;
    }
    /**
     * reset retry number
     */
    resetRetry() {
        this._retry = RETRY_NUM;
        if (this._status === "CLOSED" /* CLOSED */) {
            this._initSocket();
        }
    }
    /**
     * subscribe the socket worker events
     * @param subscriber
     */
    subscribe(subscriber) {
        this._subscriber = subscriber;
        return this;
    }
    //==========================private method================================
    _initSocket() {
        log(`SocketWorker#${this.pid} =connecting=> ${this.host}:${this.port}`);
        util_1.traceInfo(`SocketWorker#${this.pid} =connecting=> ${this.host}:${this.port}`);
        this._socket = new net_1.default.Socket();
        // Disable the Nagle algorithm.
        this._socket.setNoDelay();
        this._socket
            .connect(this.port, this.host, this._onConnected)
            .on('data', this._onData)
            .on('error', this._onError)
            .on('close', this._onClose);
    }
}
exports.default = SocketWorker;

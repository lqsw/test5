"use strict";
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const ip_1 = __importDefault(require("ip"));
const pid = process.pid;
const ipAddr = ip_1.default.address();
exports.msg = new events_1.EventEmitter();
exports.isDevEnv = process.env.NODE_ENV !== 'production';
/**
 * yes, just do nothing.
 */
exports.noop = () => { };
/**
 * trace log
 * @param info
 */
exports.trace = (obj) => {
    setImmediate(() => {
        exports.msg.emit('sys:trace', Object.assign({
            time: new Date().toISOString(),
            pid,
            host: ipAddr,
        }, obj));
    });
};
exports.traceInfo = (info) => {
    exports.trace({ type: 'INFO', msg: info });
};
exports.traceErr = (err) => {
    exports.trace({ type: 'ERR', msg: err });
};
exports.eqSet = (as, bs) => {
    //equal size?
    if (as.size !== bs.size) {
        return false;
    }
    //different element
    for (var a of as) {
        if (!bs.has(a)) {
            return false;
        }
    }
    //same
    return true;
};
exports.delay = (timeout) => {
    return new Promise(resolve => {
        setTimeout(resolve, timeout);
    });
};
